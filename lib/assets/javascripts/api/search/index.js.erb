//= require utils/worker
//= require utils/ajax
//= require api/routes
//= require api/airports
//= require api/airlines
//= require api/currency
//= require api/gates

//= require api/search/filter
//= require api/search/sort

NANO("api.search", function (NANO) {
  var search = {

    _each: {},
    _collection: {},
    _ready_callbacks: [],

    _init_sequence: [
      "airlines",
      "airports",
      "currency_rates",
      "gates_info",
      "metadata",
      "nearest_cities_prices",
      "minimal_prices",
      "params_attributes",
      "request_params",
      "tickets"
    ],

    new_search: function(search_data){
      var self = this;
      var request_params = {};
      var ajax_params = {
        url: NANO.api.routes("searches_path"),
        type: search_data.method,
        dataType: 'json',
        data: search_data.data,
        success: function(data){
          data.request_params = search_data.data;
          self.create(data, search_data.success);
        },
        error: search_data.error
      };
      NANO.utils.ajax(ajax_params);
    },

    create: function (json, complete) {
      json.minimal_prices = {};
      json.expires = +new Date() + 5000;// json.search_cache_time * 60 * 1000;
      var search_results = _.extend({}, json);
      search_results.raw = json;
      var self = this;
      var worker = null;

      _.each(this._init_sequence, function(field_name){
        var Collection = self._collection[field_name];
        var params = {
          data: search_results[field_name] || [],
          after: function(results){
            if(!results || results.length === 0){
              return false;
            }
            if(Collection){
              return new Collection(results, {
                search_id: search_results.search_id
              });
            }
            return results;
          },
          complete: function(results){
            if(results){
              search_results[field_name] = results;
            }
          }
        };
        if(self._each[field_name]){
          var Item = self._each[field_name];
          params.iterator = function(data){
            return new Item(data, search_results);
          };
        }
        if(!worker){
          worker = NANO.utils.worker(params);
        }else{
          worker = worker.then(params);
        }
      });

      worker.then({
        data: search_results,
        complete: function(search_results){
          _.each(self._ready_callbacks, function(callback){
            callback(search_results);
          });
          if(_.isFunction(complete)){
            complete(search_results);
          }
          window.CURRENT_SEARCH = search_results;
        }
      });

      return worker;
    },

    each: function(field, constructor){
      this._each[field] = constructor;
    },

    collection: function (field, constructor){
      this._collection[field] = constructor;
    },

    customize: function (process_type, name, handler) {
      var constructor = this["_" + process_type][name];
      handler.call(constructor.prototype, constructor.prototype);
    },
    ready: function(callback){
      this._ready_callbacks.push(callback);
    }
  };

  var Data = function(json){
    this._data = json;
  };
  Data.prototype = {
    get: function(id){
      return id ? this._data[id] : this._data;
    }
  };

  search.collection("airlines", function(airlines){
    NANO.api.airlines.update(airlines);
    return NANO.api.airlines;
  });
  search.collection("airports", function(airports){
    NANO.api.airports.update(airports);
    return NANO.api.airports;
  });

  var MinimalPrices = function(data, search_params){
    this.search_id = search_params.search_id;
  };
  MinimalPrices.prototype = {
    _cache: {
      _storage: {
        week: {},
        month: {}
      },
      week: function(params, data){
        var key = _.map(params, function(value){return value}).join("|");
        if(!data){
          return this._storage.week[key];
        }else {
          this._storage.week[key] = data;
        }
      },
      month: function(params, data){
        var key = _.map(params, function(value){return value}).join("|");
        if(!data){
          return this._storage.month[key];
        } else {
          this._storage.month[key] = data;
        }
      }
    },
    _request: function(params, type){
      var cached = this._cache[type](params.data);
      if(cached){
        return NANO.set_zero_timeout(function(){
          params.success(cached);
        });
      } else {
        var self = this;
        var success = params.success;
        params.success = function(data){
          self._prepare_data[type](data, function(prepared_data){
            self._cache[type](params.data, prepared_data);
            success(prepared_data);
          });
        }
        NANO.utils.ajax(_.extend({
          dataType: 'json',
          url: NANO.api.routes(type + "_minimal_prices")
        }, params));
      }
    },
    _prepare_data: {
      month: function(data, ready){
        var month = data.month.split("-");
        month[1] = +month[1];
        month[2] = 0;
        var month_days_quantity = new Date(Date.UTC.apply(Date.UTC, month)).getDate();
        var days_needed = month_days_quantity - data.values.length;
        while(0 < days_needed){
          data.values.unshift(null);
          days_needed--;
        }

        NANO.utils.worker({
          data: data.values,
          iterator: function(day_data){
            if(day_data === null || _.isEmpty(day_data)){
              return null;
            }
            return day_data;
          },
          complete: function(ready_values){
            data.values = ready_values;
            ready(data);
          }
        });
      },
      week: function(data, ready){
        var async_worker = null;
        _.each(data.values, function(week_values, index){
          var iteration = index + "";
          var asyc_data = {
            data: week_values,
            iterator: function(day_value){
              if(day_value === null){
                return null;
              }
              var day_data = {};
              _.each(day_value, function(value, stops_count){
                day_data[stops_count] = {
                  value: value
                };
              });
              return day_data;
            },
            complete: function(result){
              data.values[index] = result;
            }
          };
          if(!async_worker){
            async_worker = NANO.utils.worker(asyc_data);
          } else {
            async_worker = async_worker.then(asyc_data);
          }
        }); 

        async_worker.then({
          data: data,
          complete: ready
        });
      }
    },
    month: function(params, success, error){
      this._request({
        data: {
          search_id: this.search_id,
          month: params.month
        },
        success: success,
        error: error
      }, "month");
    },
    week: function(params, success, error){
      var request_params = {
        data: {
          search_id: this.search_id,
          direct_date: +new Date(params.depart_date) / 1000
        },
        success: success,
        error: error
      };
      if(params.retur_date){
        request_params.data.return_date = +new Date(params.return_date) / 1000;
      }
      this._request(request_params, "week");
    }
  };

  search.collection("minimal_prices", MinimalPrices);
  search.collection("params_attributes", Data);
  search.collection("request_params", Data);

  search.collection("currency_rates", function(rates){
    NANO.api.currency.update_rates(rates);
    return rates;
  });

  search.collection("gates_info", function(gates_info){
    NANO.api.gates.update(gates_info);
    return NANO.api.gates;
  });

  var memoize = function(this_object){
    _.each(this_object.memoize, function(method_name){
      this_object[method_name] = _.memoize(this_object[method_name]);
    });
  };

  var Flights = function(flights_array, direction){
    this.direction = direction;
    this.data = flights_array;
    this.flights = _.map(flights_array, function(flight_json){
      return new Flight(flight_json, direction);
    });
    memoize(this);
  };
  Flights.prototype = {
    memoize: ['airlines', 'aircompany', 'duration', 'stops_count', 'stops_durations', 'stops_iatas', 'airline_duration'],
    get_flights_values: function(field_name, is_function, params){
      is_function = !!is_function;
      params = params || [];
      return _.map(this.flights, function(flight){
        if(is_function){
          return flight[field_name].apply(flight, params);
        }else {
          return flight.data[field_name];
        }
      });
    },
    list: function(){
      return this.flights;
    },
    origin: function(){
      return this.flights[0].origin();
    },
    destination: function(){
      return _.last(this.flights).destination();
    },
    duration: function(){
      return _.reduce(this.flights, function(duration, flight){
        return duration + flight.data.duration + flight.data.delay;
      }, 0);
    },
    numbers: function(){
      return this.get_flights_values("number");
    },
    airlines: function(){
      return _.uniq(this.get_flights_values("airline"));
    },
    alliances: function(){
      return _.uniq(this.get_flights_values("alliance", true));
    },
    airports: function(){
      var airports = [];
      _.each(this.flights, function(flight){
        airports = airports.concat(flight.airports());
      });
      return airports;
    },
    airline_duration: function(){
      return _(this.list()).chain().
      reduce(function(hash, flight){
        var airc = flight.airline();
        hash[airc] = hash.hasOwnProperty(airc) ? hash[airc] + flight.duration() : flight.duration();
        return hash;
      }, {}).
      map(function(flight_duration, aircompany_iata){
        return {
          duration: flight_duration,
          iata: aircompany_iata
        };
      }).
      max(function(info){
        return info.duration;
      }).
      value();
    },

    airline: function(){
      return this.airline_duration().iata;
    },
    depart_time: function(){
      return this.flights[0].depart_time();
    },
    depart_timestamp: function(){
      return this.flights[0].depart_timestamp();
    },
    arrival_timestamp: function(){
      return _.last(this.flights).arrival_timestamp();
    },
    stops_iatas: function(){
      return _.map(this.stops(), function(stop_data){
        return stop_data.iata;
      });
    },
    stops: function(){
      return _.compact(this.get_flights_values("stop_data", true));
    },
    stops_count: function(){
      return Math.max(this.flights.length - 1, 0);
    },
    stops_durations: function(){
      return _.compact(_.uniq(this.get_flights_values("delay")));
    }
  };

  var milliseconds_in_day = 24 * 60 * 60 * 1000;

  var Flight = function(flight_json, direction){
    this.direction = direction;
    this.data = flight_json;
    this.data.alliance = this.data.alliance || NANO.api.airlines.get(this.airline()).alliance_name;
  };
  Flight.prototype = {
    duration: function(){
      return this.data.duration;
    },
    number: function(){
      return this.data.number;
    },
    airline: function(){
      return this.data.airline;
    },
    alliance: function(){
      return this.data.alliance;
    },
    airports: function(){
      return [this.data.origin, this.data.destination];
    },
    origin: function(){
      return this.data.origin;
    },
    destination: function(){
      return this.data.destination;
    },
    depart_time: function(){
      return this.depart_timestamp() % milliseconds_in_day;
    },
    depart_timestamp: function(){
      return this.data.departure * 1000;
    },
    arrival_timestamp: function(){
      return this.data.arrival * 1000;
    },
    stop_data: function(){
      if(this.data.delay && 0 < this.data.delay){
        return {
          iata: this.data.origin,
          delay: this.data.delay
        };
      }else{
        return null;
      }
    }
  };


  //добавляем сами билеты
  var Ticket = function(ticket_json, search){
    search = search || {};
    this.search_id = ticket_json.search_id || search.search_id;
    this.expires = ticket_json.expires || search.expires;
    this._data = ticket_json;
    var self = this;
    _.each(["direct", "return"], function(direction){
      var name = direction + "_flights";
      if(ticket_json[name] && 0 < ticket_json[name].length){
        self[name] = new Flights(ticket_json[name], direction);
      }
    });

    this.id = ticket_json.id || "ticket_" + this.flight_numbers().join("-");
    
    var ticket_arguments = arguments;
    _.each(this.init_stack, function(method){
      if(_.isFunction(method)){
        method.apply(self, ticket_arguments);
      } else {
        self[method].apply(self, self);
      }
      
    });
    memoize(this);
  };
  Ticket.prototype = {
    fn: Ticket.prototype,
    init_stack: [],
    memoize: [],
    context: function(){
      var data = {};
      var self = this;
      _.each(["airlines", "airports"], function(name){
        var list = self.direct_flights[name]();
        if(self.return_flights){
          list = list.concat(self.return_flights[name]());
        }
        var collected_data = {};
        _.each(list, function(id){
          collected_data[id] = NANO.api[name].get(id);
        });
        data[name] = collected_data;
      });
      return data;
    },
    serialize: function(extention){
      return _.extend({
        id: this.id,
        search_id: this.search_id,
        direct_flights: this.direct_flights.data,
        return_flights: this.return_flights ? this.return_flights.data : undefined,
        expires: this.expires,
        gates: this.gates()
      }, extention);
    },
    flight_numbers: function(){
      var self = this;
      return _.map(["direct", "return"], function(direction){
        var flights = self[direction + "_flights"];
        if(flights){
          return flights.numbers().join(",");
        }
      });
    },
    main_airline: function(){
      var direct_airline = this.direct_flights.airline_duration();
      var return_airline = this.return_flights ? this.return_flights.airline_duration() : {};
      return _.max([direct_airline, return_airline], function(airline){
        return airline.duration;
      }).iata;
    },
    url: function(){
      return NANO.api.routes("search", {
        search_id: this.search_id,
        ticket_id: this.id,
        price: this.gates()[0].default_currency_price.value
      });
    },
    airline_deeplink: function(){
      var airline_gate = _.chain(this.gates()).
        filter(function(gate){
          return gate.is_airline;
        }).
        min(function(gate){
          return gate.default_currency_price.value;
        }).
        value();

      if(airline_gate){
        return {
          type: "gate",
          url: airline_gate.url,
          price: airline_gate.price
        };
      }
      var main_airline = NANO.api.airlines.get(this.main_airline());
      if(main_airline.deeplink_id){
        return {
          type: "deeplink",
          url: NANO.api.routes("airline_deeplink", this._deeplink_request_params(main_airline.deeplink_id)),
          price: null
        };
      }
      return false;
    },
    _deeplink_request_params: function(deeplink_id){
      var params = {
        id: deeplink_id,
        search_id: this.search_id,
        origin: this.direct_flights.origin(),
        destination: this.direct_flights.destination(),
        depart_date: this.direct_flights.depart_timestamp(),
        flight_numbers: this.flight_numbers().join(";")
      };
      if(this.return_flights){
        params.return_date = this.return_flights.depart_timestamp();
      }
      _.each(["depart_date", "return_date"], function(name){
        params[name] = GC.utils.dates.formatter.server_request(params[name]);
      });
      return params;
    },
    gates: function(){
      var self = this;
      if(!this._data.gates){
        this._data.gates = [];
        _.each(this._data.order_urls, function(url_id, id){
          var gate = NANO.api.gates.get(id);

          var default_currency_price = NANO.api.currency.to_default({
            value: self._data.native_prices[id],
            currency: gate.currency_code
          });

          self._data.gates.push({
            ticket_id: self.id,
            id: id,
            name: gate.label,
            is_airline: gate.is_airline,
            payment_methods: gate.payment_methods,
            price: NANO.api.currency.to_current(default_currency_price),
            default_currency_price: default_currency_price,
            url: NANO.api.routes("search_click_path", {
              id: url_id,
              search_id: self.search_id
            }),
            type: "redirect"
          });
        });
      }
      

      this._data.gates = this._data.gates.sort(function(gate_a, gate_b){
        return gate_a.default_currency_price.value < gate_b.default_currency_price.value ? (-1) : (1);
      });

      var param_cache = {};

      this.gates = function(param){
        if(param){
          if(!param_cache[param]){
            param_cache[param] =  _.map(self._data.gates, function(gate){
              return gate[param];
            });
          }
          return param_cache[param];
        }
        return self._data.gates.concat([]);
      };
      return this.gates();
    },
    minimal_price: function(){
      return _.min(this.gates("default_currency_price"), function(price){
        return price.value;
      }).value;
    }
  };
  search.each("tickets", Ticket);

  var Tickets = function(tickets, params){
    this.list = tickets;
    if(params){
      _.extend(this, params);
    }
    var self = this;
    _.each(this.list, function(ticket){
      ticket.tickets = self;
    });
    _.each(this.init_stack, function(method){
      method.call(self);
    });
    this._tickets_index = 0;
  };
  Tickets.prototype = {
    next_tickets_count: 10,
    _constructor: Tickets,
    fn: Tickets.prototype,
    init_stack: [],
    _self: function(tickets, params){
      params.search_id = this.search_id;
      return new this._constructor(tickets, params);
    },
    minimal_price: function(){
      return _.min(this.list, function(ticket){
        return ticket.minimal_price();
      }).minimal_price();
    },
    get: function(id){
      if(_.isString(id)){
        return _.detect(this.list, function(ticket){
          return ticket.id === id;
        });
      }
      return this.list;
    },
    next: function(count){
      var start = this._tickets_index;
      var end = start + (count || this.next_tickets_count);
      this._tickets_index = end;
      return this.list.slice(start, end);
    }
  };
  search.collection("tickets", Tickets);
  return search;
}, {
  require: ["api.routes", "utils.worker", "utils.ajax", "api.airports", "api.airlines", "api.currency", "api.gates"]
});